#!/usr/bin/env python

# NOTE: The script uses multithreading to parse sv tags. 
#       Sometimes the results generated by the script are incomplete. But sometimes its complete

import sys, getopt
import os
import threading
import subprocess


#sys.path.append()

from utils.ctags import Ctags
from ThreadManager.manager import get_default_server
#from utils.search import search_tags

def GetOpt(argv):
  opts_h = {}
  try:
    opts, args = getopt.getopt(argv,"hd:o:",["ofile="])
    if opts == [] and args == []:
      print ('"Usage: test.py -f <outfile>"')
  except getopt.GetoptError:
    print ('echoerr "Usage: test.py -f <outfile>"')
    return None
  for opt, arg in opts:
    if opt == '-h':
      print ('echoerr "Usage: test.py -f <outfile>"')
      return None
    elif opt in ("-d", "--dir"):
      opts_h['dir'] = arg
    #elif opt in ("-t", "--tagfile"):
    #  opts_h['tagfile'] = arg

  return opts_h, args  

class CtagsTread(threading.Thread):
  """class: CtagsTread"""
  def __init__(self, m_semaphore, infiles):
    threading.Thread.__init__(self)
    self.infiles = infiles
    self.m_semaphore = m_semaphore
    self.event = threading.Event()

  def run (self):
    """def: run"""
    #self.event.clear()
    self.m_semaphore.acquire()
    subprocess.call('vim -N -u NONE -Resnc "pyfile $KP_VIM_HOME/python_lib/vim/ctags/main_mp.py" +"qa!" {infiles}'.format(infiles=' '.join(self.infiles)), shell=True)
    self.m_semaphore.release()
    #self.event.set()

# || ALTERNATE_PARTS || def split_array(alist, parts=10):
# || ALTERNATE_PARTS ||   length = len(alist)
# || ALTERNATE_PARTS ||   return [ alist[i*length // parts: (i + 1) * length // parts] for i in range(parts) ]

def split_array(alist, maximum=10):
  length = len(alist)
  idx = 0
  rlist = []
  while idx < length:
    if length < idx + maximum:
      rlist.append(alist[idx: length])
    else:
      rlist.append(alist[idx: idx + maximum])

    idx += maximum

  return rlist

if __name__ == "__main__":

  opts_h, files = GetOpt(sys.argv[1:])

  outfile = '{0}/tags'.format(opts_h['dir'])

  m_queue_server = get_default_server()
  m_queue_server.start()

  m_ctags = Ctags(outfile)

  m_threads = []
  m_semaphore = threading.BoundedSemaphore(5) # Max number of threads to be passed

  # || NON_THREAD|| subprocess.call('vim -N -u NONE -Resnc "pyfile $KP_VIM_HOME/python_lib/vim/ctags/__main__.py" +"qa!" {infiles}'.format(infiles=' '.join(files)), shell=True) 

  # || SINGLE_THREAD|| m_thread = CtagsTread(m_semaphore, files)
  # || SINGLE_THREAD|| m_thread.start()
  # || SINGLE_THREAD|| m_threads.append(m_thread)

  print "parsing total {0} files...".format(len(files))

  for fnames in split_array(files, 50): # minimun number of files processed in single thread
    m_thread = CtagsTread(m_semaphore, fnames)
    m_thread.start()
    m_threads.append(m_thread)

  # Wait for threads to be completed
  for t in m_threads:
    t.join()
    # || INCOMPLETE TAGS RESULT IN TAG FILE || done = t.event.wait(timeout=60.0)
    # || INCOMPLETE TAGS RESULT IN TAG FILE || if not done :
    # || INCOMPLETE TAGS RESULT IN TAG FILE ||   print "Error: While processing files {file} !! Thread is still running...".format(file=t.infiles)

  # || DEBUG || raw_input("Press any key to kill server".center(50, "-"))

  while not m_queue_server.queue.empty():
    m_token = m_queue_server.queue.get()
    m_ctags.write(m_token)

  m_queue_server.shutdown()









